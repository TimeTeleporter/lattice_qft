#![allow(incomplete_features)]
#![feature(generic_const_exprs)]
#![feature(generic_arg_infer)]
#![feature(split_array)]

use lattice_qft::{
    field3d::Field3d, lattice3d::Lattice3d, metropolis::Metropolis, observable::Action,
};

/// We initialize a 2 by 2 by 2 lattice, on which all possible configurations
/// with values from 0 to 8 are known. Then we run a metropolis simulation
/// in order to test that it converges to the desired distribution.
fn main() {
    const TEST_X: usize = 2;
    const TEST_Y: usize = 2;
    const TEST_T: usize = 2;

    const TEST_RANGE: usize = 16;
    const SIZE: usize = TEST_X * TEST_Y * TEST_Y; // 8 lattice points

    const PERMUTATIONS: usize = TEST_RANGE.pow(SIZE as u32 - 1); // 16 ^ 7 = 268’435’456

    // Initialize the lattice
    let lattice: Lattice3d<TEST_X, TEST_Y, TEST_T> = Lattice3d::new();

    // Saving all possible configurations
    let mut configurations: Vec<Field3d<i8, TEST_X, TEST_Y, TEST_T>> =
        Vec::with_capacity(PERMUTATIONS);
    let mut field: Field3d<i8, TEST_X, TEST_Y, TEST_T> = Field3d::new(&lattice);
    configurations.push(field.clone());

    const BOUDARY: i8 = TEST_RANGE as i8 - 1;

    for _ in 0..PERMUTATIONS {
        'updateconfig: for index in 0..SIZE {
            match field.values[index] {
                x if x < BOUDARY => {
                    field.values[index] = field.values[index] + 1;
                    break 'updateconfig;
                }
                x if x == BOUDARY => {
                    field.values[index] = 0;
                }
                _ => {
                    panic!("config entry out of bounds.");
                }
            }
        }
        configurations.push(field.clone());
    }
    println!("All possible permutations are saved!");

    let mut test_ary: Vec<f64> = Vec::with_capacity(PERMUTATIONS);
    let mut part_ary: Vec<f64> = Vec::with_capacity(PERMUTATIONS);

    // Calculate the weihghts of all configurations
    for field in configurations.into_iter() {
        let field: Field3d<i32, TEST_X, TEST_Y, TEST_T> = Field3d::from_field(field);
        let bolz: f64 = (-field.lattice_action()).exp();
        test_ary.push(field.lattice_action() * bolz);
        part_ary.push(bolz);
    }

    // The partition function is the sum over all Bolzmann weihgts
    let partfn: f64 = part_ary.into_iter().sum();

    // The observable is the sum over all weights (Bolzmann times observable),
    // devided by the partition function.
    let test: f64 = test_ary.into_iter().sum();
    let test: f64 = test / partfn;

    std::mem::drop(partfn);
    println!("Observable is calculated!");

    // Initialize a field to compare against
    let field: Field3d<i8, TEST_X, TEST_Y, TEST_T> = Field3d::random(&lattice);
    field.print_values_formated();
    let mut field: Field3d<i32, TEST_X, TEST_Y, TEST_T> = Field3d::from_field(field);
    println!("Markov chain initialized!");

    const BURNIN: usize = 2500; // Number of sweeps until it starts counting.
    const MAX_TRIES: usize = 1_000_000;

    // Sweeps to achieve equilibrium
    for _ in 0..BURNIN {
        field.metropolis_sweep();
    }
    println!("Burned in!");

    // After having reached equilibrium, for each consecutive field configuration
    // that is generated by the markov chain, we calculate the observable and average it.
    let mut sim: f64 = 0.0;
    for sweeps in 0..MAX_TRIES {
        field.metropolis_sweep();
        sim = sim + field.lattice_action();
        println!(
            "Action: {}, Test: {}, Sim: {}",
            field.action_observable(),
            test,
            sim / sweeps as f64
        );
    }
}
