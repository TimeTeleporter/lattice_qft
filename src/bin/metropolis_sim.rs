//! This binary calculates a metropolis simulation and saves the result in a csv file.
#![allow(incomplete_features)]
#![feature(generic_const_exprs)]
#![feature(generic_arg_infer)]
#![feature(split_array)]

use lattice_qft::{
    export::CsvData, field3d::Field3d, lattice3d::Lattice3d, metropolis::Metropolis,
    observable::Action,
};

use serde::{Deserialize, Serialize};

const TEST_X: usize = 2;
const TEST_Y: usize = 2;
const TEST_T: usize = 2;
const _SIZE: usize = TEST_X * TEST_Y * TEST_Y; // 8 lattice points

const BINS_PATH: &str = "data/metropolis_data.csv";
const RESULTS_PATH: &str = "data/metropolis_results.csv";

const BURNIN: usize = 10_000; // Number of sweeps until it starts counting.
const MAX_TRIES: usize = 1_000_000;

const LOG_COEFF: [f32; 10] = [
    1.0, 1.25892, 1.58489, 1.99526, 2.51188, 3.16227, 3.98107, 5.01187, 6.30957, 7.94328,
];

/// Datatype to save and read simulation output.
#[derive(Debug, Serialize, Deserialize)]
struct MetropolisSimResults {
    temp: f64,
    sim_burnin: usize,
    sim_iterations: usize,
    sim_observable: f64,
    sim_variance: f64,
}

/// A wrapper for the Markov chain elements generated by the Metropolis simulation.
#[derive(Debug)]
struct MetropolisSimData(Vec<f64>);

/// Datatype to save and read binned simulation output.
#[derive(Debug, Serialize, Deserialize)]
struct MetropolisBinData {
    bin_size: usize,
    bin_variance: f64, // The square of the standard deviation
}

/// We initialize a 2 by 2 by 2 lattice, on which all possible configurations
/// with values from 0 to 8 are known. Then we run a metropolis simulation
/// in order to test that it converges to the desired distribution.
fn main() {
    const _EXPO_ARY: [f64; 41] = [
        -3.0, -2.9, -2.8, -2.7, -2.6, -2.5, -2.4, -2.3, -2.2, -2.1, -2.0, -1.9, -1.8, -1.7, -1.6,
        -1.5, -1.4, -1.3, -1.2, -1.1, -1.0, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4, -0.3, -0.2, -0.1,
        0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0,
    ];

    // Initialize the lattice
    let lattice: Lattice3d<TEST_X, TEST_Y, TEST_T> = Lattice3d::new();

    /*
    for expo in EXPO_ARY {
        let temp = expo.expf(10.0);

        let (data, results) = metropolis_simulation(&lattice, temp);

        if let Err(err) = results.write_to_csv(RESULTS_PATH) {
            eprint!("MetropolisSimResults Error: {}", err);
        };

        if let Err(err) = data.write_to_csv(DATA_PATH) {
            eprint!("MetropolisSimData Error: {}", err);
        };

        println!("{}: Done", temp);
    }
    */

    let temp = 0.1;

    let (data, results) = metropolis_simulation(&lattice, temp);

    if let Err(err) = results.read_write_csv(RESULTS_PATH) {
        eprint!("MetropolisSimResults Error: {}", err);
    };

    for bin_variance in calculate_bin_var(data) {
        if let Err(err) = bin_variance.read_write_csv(BINS_PATH) {
            eprint!("MetropolisSimData Error: {}", err);
        };
    }

    println!("{}: Done", temp);
}

fn calculate_bin_var(data: MetropolisSimData) -> Vec<MetropolisBinData> {
    let mut results: Vec<MetropolisBinData> = Vec::new();

    let mut exp: u32 = 0;
    'outer: loop {
        let mut last_bin_size: usize = 0;
        'inner: for coeff in LOG_COEFF {
            let bin_size: usize = (coeff * 10_u32.pow(exp) as f32) as usize;
            last_bin_size = if last_bin_size == bin_size {
                continue 'inner;
            } else {
                bin_size
            };

            let bins_amount: usize = data.0.len() / bin_size + 1;
            // Initialize the bins
            let mut bins: Vec<Vec<f64>> = vec![Vec::new(); bins_amount];

            for (index, &entry) in data.0.iter().enumerate() {
                let bin_number: usize = index / bin_size;
                bins[bin_number].push(entry);
            }

            let mut variances: Vec<f64> = Vec::new();

            for bin in bins {
                if bin.len() == 0 {
                    continue;
                }
                let length = bin.len() as f64;
                let mean: f64 = bin.iter().sum::<f64>() / length;
                let variance: f64 = bin
                    .into_iter()
                    .map(|x| (mean - x) * (mean - x))
                    .sum::<f64>()
                    / length;
                variances.push(variance);
            }

            let bin_variance: f64 = variances.iter().sum::<f64>() / variances.len() as f64;

            results.push(MetropolisBinData {
                bin_size,
                bin_variance,
            });

            if bin_size >= data.0.len() {
                break 'outer;
            }
        }
        exp += 1;
    }

    results
}

fn metropolis_simulation(
    lattice: &Lattice3d<TEST_X, TEST_Y, TEST_T>,
    temp: f64,
) -> (MetropolisSimData, MetropolisSimResults) {
    // Initialize a field to compare against
    let field: Field3d<i8, TEST_X, TEST_Y, TEST_T> = Field3d::random(&lattice);
    //field.print_values_formated();
    let mut field: Field3d<i32, TEST_X, TEST_Y, TEST_T> = Field3d::from_field(field);

    // Sweeps to achieve equilibrium
    for _ in 0..BURNIN {
        field.metropolis_sweep(temp);
    }

    // After having reached equilibrium, for each consecutive field configuration
    // that is generated by the markov chain, we calculate the observable and average it.
    let mut sim_obs_ary: Vec<f64> = Vec::new();
    for _sweeps in 0..MAX_TRIES {
        field.metropolis_sweep(temp);
        sim_obs_ary.push(field.lattice_action(temp));
    }
    let sim_observable: f64 = sim_obs_ary.iter().sum::<f64>() / MAX_TRIES as f64;
    let sim_variance: f64 = sim_obs_ary
        .iter()
        .map(|x| (sim_observable - x) * (sim_observable - x))
        .sum::<f64>()
        / MAX_TRIES as f64;

    let data = MetropolisSimData(sim_obs_ary);

    let results: MetropolisSimResults = MetropolisSimResults {
        temp,
        sim_burnin: BURNIN,
        sim_iterations: MAX_TRIES,
        sim_observable,
        sim_variance,
    };

    println!("{:?}", results);

    (data, results)
}
