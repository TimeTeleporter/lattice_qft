//! This binary calculates a metropolis simulation and saves the result in a csv file.
#![allow(incomplete_features)]
#![feature(generic_const_exprs)]
#![feature(generic_arg_infer)]
#![feature(split_array)]

use std::error::Error;

use lattice_qft::{
    action::Action,
    export::{clean_csv, CsvData},
    field::Field3d,
    lattice::Lattice3d,
    metropolis::Metropolis,
};

use serde::{Deserialize, Serialize};

const TEST_X: usize = 2;
const TEST_Y: usize = 2;
const TEST_T: usize = 2;
const _SIZE: usize = TEST_X * TEST_Y * TEST_Y; // 8 lattice points

const BINS_PATH: &str = "data/metropolis_bins.csv";
const _DATA_PATH: &str = "data/metropolis_data.csv";
const RESULTS_PATH: &str = "data/metropolis_results.csv";

const BURNIN: usize = 100_000; // Number of sweeps until it starts counting.
const MAX_TRIES: usize = 10_000_000;

const _LOG_COEFF: [f32; 10] = [
    1.0, 1.25892, 1.58489, 1.99526, 2.51188, 3.16227, 3.98107, 5.01187, 6.30957, 7.94328,
];

/// Datatype to save and read simulation output.
#[derive(Debug, Clone, Serialize, Deserialize)]
struct MetropolisSimResults {
    temp: f64,
    sim_burnin: usize,
    sim_iterations: usize,
    sim_observable: f64,
    sim_variance: f64,
}

/// Datatype to save and read binned simulation output.
#[derive(Debug, Serialize, Deserialize)]
struct MetropolisBinData {
    binning_step: u32,
    variance: f64, // The square of the standard deviation
    std: f64,
    error: f64,
}

/// A wrapper for the Markov chain elements generated by the Metropolis simulation.
#[derive(Debug, Clone, Serialize, Deserialize)]
struct MarkovWrapper(Vec<f64>);

impl MarkovWrapper {
    fn calculate_mean_value(&self) -> f64 {
        self.0.iter().sum::<f64>() / self.0.len() as f64
    }

    fn calulate_variance(&self) -> f64 {
        let mean = self.calculate_mean_value();

        self.0.iter().map(|&x| (x - mean) * (x - mean)).sum::<f64>() / (self.0.len() - 1) as f64
    }

    fn binning(self) -> Self {
        let new_len: usize = self.0.len() / 2;
        let mut new_set: Vec<f64> = Vec::with_capacity(new_len);

        for index in 0..new_len {
            let first: f64 = self.0[index * 2];

            let mean: f64 = if let Some(second) = self.0.get((index * 2) + 1) {
                (first + second) / 2.0
            } else {
                first
            };

            new_set.push(mean);
        }

        MarkovWrapper(new_set)
    }
}

/// We initialize a 2 by 2 by 2 lattice, on which all possible configurations
/// with values from 0 to 8 are known. Then we run a metropolis simulation
/// in order to test that it converges to the desired distribution.
fn main() {
    // Initialize the lattice
    let lattice: Lattice3d<TEST_X, TEST_Y, TEST_T> = Lattice3d::new();

    let temp = 0.1;

    let (data, results) = metropolis_simulation(&lattice, temp);

    if let Err(err) = metropolis_output(data, results) {
        eprint!("{}", err);
    }

    println!("{}: Done", temp);
}

fn metropolis_output(
    data: MarkovWrapper,
    results: MetropolisSimResults,
) -> Result<(), Box<dyn Error>> {
    results.clone().read_write_csv(RESULTS_PATH)?;

    clean_csv(BINS_PATH)?;

    for bin_variance in calculate_bin_var(data.clone(), results.temp, results.sim_observable) {
        bin_variance.read_write_csv(BINS_PATH)?;
    }

    //data.overwrite_csv(DATA_PATH)?;

    Ok(())
}

fn calculate_bin_var(
    mut data: MarkovWrapper,
    _temp: f64,
    _sim_observable: f64,
) -> Vec<MetropolisBinData> {
    let mut results: Vec<MetropolisBinData> = Vec::new();
    let original_length: usize = data.0.len();

    let mut binning_step: u32 = 0;
    while 2_usize.pow(binning_step) < original_length {
        let variance: f64 = data.calulate_variance();
        let std: f64 = variance.sqrt();
        let error: f64 = std / ((data.0.len() - 1) as f64).sqrt();

        data = data.binning();

        results.push(MetropolisBinData {
            binning_step,
            variance,
            std,
            error,
        });

        binning_step += 1;
    }

    results
}

fn metropolis_simulation(
    lattice: &Lattice3d<TEST_X, TEST_Y, TEST_T>,
    temp: f64,
) -> (MarkovWrapper, MetropolisSimResults) {
    // Initialize a field to compare against
    let field: Field3d<i8, TEST_X, TEST_Y, TEST_T> = Field3d::random(&lattice);
    //field.print_values_formated();
    let mut field: Field3d<i32, TEST_X, TEST_Y, TEST_T> = Field3d::from_field(field);

    // Sweeps to achieve equilibrium
    for _ in 0..BURNIN {
        field.metropolis_sweep(temp);
    }

    // After having reached equilibrium, for each consecutive field configuration
    // that is generated by the markov chain, we calculate the observable and average it.
    let mut sim_obs_ary: Vec<f64> = Vec::new();
    for _sweeps in 0..MAX_TRIES {
        field.metropolis_sweep(temp);
        sim_obs_ary.push(field.lattice_action(temp));
    }

    // Mean value of the lattice actions generated by the sim
    let sim_observable: f64 = sim_obs_ary.iter().sum::<f64>() / sim_obs_ary.len() as f64;

    let sim_variance: f64 = sim_obs_ary
        .iter()
        .map(|x| (sim_observable - x) * (sim_observable - x))
        .sum::<f64>()
        / (sim_obs_ary.len() as f64 - 1.0);

    let data = MarkovWrapper(sim_obs_ary);

    let results: MetropolisSimResults = MetropolisSimResults {
        temp,
        sim_burnin: BURNIN,
        sim_iterations: MAX_TRIES,
        sim_observable,
        sim_variance,
    };

    println!("{:?}", results);

    (data, results)
}
