//! This binary calculates a metropolis simulation and saves the result in a csv file.
#![allow(incomplete_features)]
#![feature(generic_const_exprs)]
#![feature(generic_arg_infer)]
#![feature(split_array)]

use lattice_qft::{
    export::CsvData, field3d::Field3d, lattice3d::Lattice3d, metropolis::Metropolis,
    observable::Action,
};

use serde::{Deserialize, Serialize};

const TEST_X: usize = 2;
const TEST_Y: usize = 2;
const TEST_T: usize = 2;
const _SIZE: usize = TEST_X * TEST_Y * TEST_Y; // 8 lattice points

const DATA_PATH: &str = "data/metropolis_data.csv";
const RESULTS_PATH: &str = "data/metropolis_results.csv";

const BURNIN: usize = 10_000; // Number of sweeps until it starts counting.
const MAX_TRIES: usize = 1_000_000;

/// Datatype to save and read simulation output.
#[derive(Debug, Serialize, Deserialize)]
struct MetropolisSimResults {
    temp: f64,
    sim_burnin: usize,
    sim_iterations: usize,
    sim_observable: f64,
}

#[derive(Debug, Serialize, Deserialize)]
struct MetropolisSimData(Vec<f64>);

/// We initialize a 2 by 2 by 2 lattice, on which all possible configurations
/// with values from 0 to 8 are known. Then we run a metropolis simulation
/// in order to test that it converges to the desired distribution.
fn main() {
    const _EXPO_ARY: [f64; 41] = [
        -3.0, -2.9, -2.8, -2.7, -2.6, -2.5, -2.4, -2.3, -2.2, -2.1, -2.0, -1.9, -1.8, -1.7, -1.6,
        -1.5, -1.4, -1.3, -1.2, -1.1, -1.0, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4, -0.3, -0.2, -0.1,
        0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0,
    ];

    // Initialize the lattice
    let lattice: Lattice3d<TEST_X, TEST_Y, TEST_T> = Lattice3d::new();

    /*
    for expo in EXPO_ARY {
        let temp = expo.expf(10.0);

        let (data, results) = metropolis_simulation(&lattice, temp);

        if let Err(err) = results.write_to_csv(RESULTS_PATH) {
            eprint!("MetropolisSimResults Error: {}", err);
        };

        if let Err(err) = data.write_to_csv(DATA_PATH) {
            eprint!("MetropolisSimData Error: {}", err);
        };

        println!("{}: Done", temp);
    }
    */

    let temp = 0.1;

    let (data, results) = metropolis_simulation(&lattice, temp);

    let bin_variances: MetropolisSimData = calculate_bin_var(data);

    if let Err(err) = results.read_write_csv(RESULTS_PATH) {
        eprint!("MetropolisSimResults Error: {}", err);
    };

    if let Err(err) = bin_variances.read_write_csv(DATA_PATH) {
        eprint!("MetropolisSimData Error: {}", err);
    };

    println!("{}: Done", temp);
}

fn calculate_bin_var(data: MetropolisSimData) -> MetropolisSimData {
    let results: Vec<f64> = Vec::new();

    for bin_index in 1..data.0.len() {
        let mut bins: Vec<Vec<f64>> = Vec::new();
        for (index, &data_entry) in data.0.iter().enumerate() {
            bins[index / bin_index].push(data_entry);
        }
    }

    MetropolisSimData(results)
}

fn metropolis_simulation(
    lattice: &Lattice3d<TEST_X, TEST_Y, TEST_T>,
    temp: f64,
) -> (MetropolisSimData, MetropolisSimResults) {
    // Initialize a field to compare against
    let field: Field3d<i8, TEST_X, TEST_Y, TEST_T> = Field3d::random(&lattice);
    //field.print_values_formated();
    let mut field: Field3d<i32, TEST_X, TEST_Y, TEST_T> = Field3d::from_field(field);

    // Sweeps to achieve equilibrium
    for _ in 0..BURNIN {
        field.metropolis_sweep(temp);
    }

    // After having reached equilibrium, for each consecutive field configuration
    // that is generated by the markov chain, we calculate the observable and average it.
    let mut sim_obs_ary: Vec<f64> = Vec::new();
    for _sweeps in 0..MAX_TRIES {
        field.metropolis_sweep(temp);
        sim_obs_ary.push(field.lattice_action(temp));
    }
    let sim_observable: f64 = sim_obs_ary.iter().sum::<f64>() / MAX_TRIES as f64;

    let data = MetropolisSimData(sim_obs_ary);

    let results = MetropolisSimResults {
        temp,
        sim_burnin: BURNIN,
        sim_iterations: MAX_TRIES,
        sim_observable,
    };

    (data, results)
}
