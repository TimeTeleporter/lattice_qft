use crate::{
    action::Action,
    field::{Field, Field3d},
    lattice::Lattice3d,
};
use rand::prelude::*;
use serde::{Deserialize, Serialize};
use std::ops::{Add, Deref, DerefMut, Div, Mul, Sub};

pub trait Metropolis: Action {
    fn metropolis_single(&mut self, index: usize, temp: f64, rng: &mut ThreadRng);

    fn metropolis_random(&mut self, temp: f64) {
        let mut rng = ThreadRng::default();
        let index: usize = rng.gen_range(0..Self::SIZE);
        self.metropolis_single(index, temp, &mut rng);
    }

    fn metropolis_sweep(&mut self, temp: f64) {
        let mut rng = ThreadRng::default();
        for index in 0..Self::SIZE {
            self.metropolis_single(index, temp, &mut rng);
        }
    }
}

impl<'a, T, const D: usize, const SIZE: usize> Metropolis for Field<'a, T, D, SIZE>
where
    f64: From<T>,
    T: Add<Output = T>
        + Sub<Output = T>
        + Mul<Output = T>
        + Div<Output = T>
        + Default
        + From<i8>
        + Into<i64>
        + Into<f64>
        + PartialOrd
        + Copy,
    [(); D * 2_usize]:,
{
    fn metropolis_single(&mut self, index: usize, temp: f64, rng: &mut ThreadRng) {
        // Initialize the change to be measured
        let mut new_field = self.clone();
        let coin: bool = rng.gen();
        new_field.values[index] = match coin {
            true => new_field.values[index] + Self::FieldType::from(1_i8),
            false => new_field.values[index] - Self::FieldType::from(1_i8),
        };

        // Calculate the action of both possibilities
        let action = self.lattice_action(temp);
        let new_action = new_field.lattice_action(temp);

        // Accept the new action if its lower than the previous.
        // Else accept it with a proportional probability.
        let draw: f64 = rng.gen_range(0.0..1.0);
        let prob: f64 = (action - new_action).exp();
        if draw <= prob {
            *self = new_field;
        }
    }
}

impl<'a, T, const MAX_X: usize, const MAX_Y: usize, const MAX_T: usize> Metropolis
    for Field3d<'a, T, MAX_X, MAX_Y, MAX_T>
where
    f64: From<T>,
    T: Add<Output = T>
        + Sub<Output = T>
        + Mul<Output = T>
        + Div<Output = T>
        + Default
        + From<i8>
        + Into<i64>
        + Into<f64>
        + PartialOrd
        + Copy,
    [(); MAX_X * MAX_Y * MAX_T]:,
{
    fn metropolis_single(&mut self, index: usize, temp: f64, rng: &mut ThreadRng) {
        self.deref_mut().metropolis_single(index, temp, rng)
    }
}

/// Datatype to save and read simulation output.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetropolisSimResult {
    temp: f64,
    burnin: usize,
    iterations: usize,
    observable: f64,
}

/// A wrapper for the Markov chain elements generated by the Metropolis simulation.
#[derive(Debug, Serialize, Deserialize)]
pub struct MarkovChain(Vec<f64>);

impl MarkovChain {
    pub fn calculate_mean_value(&self) -> f64 {
        self.0.iter().sum::<f64>() / self.0.len() as f64
    }

    pub fn calulate_variance(&self) -> f64 {
        let mean = self.calculate_mean_value();

        self.0.iter().map(|&x| (x - mean) * (x - mean)).sum::<f64>() / (self.0.len() as f64)
    }

    pub fn binning(self) -> Self {
        let new_len: usize = self.0.len() / 2;
        let mut new_set: Vec<f64> = Vec::with_capacity(new_len);

        for index in 0..new_len {
            let first: f64 = self.0[index * 2];

            let mean: f64 = if let Some(second) = self.0.get((index * 2) + 1) {
                (first + second) / 2.0
            } else {
                first
            };

            new_set.push(mean);
        }

        MarkovChain(new_set)
    }
}

impl Deref for MarkovChain {
    type Target = Vec<f64>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

pub fn metropolis_simulation<const MAX_X: usize, const MAX_Y: usize, const MAX_T: usize>(
    lattice: &Lattice3d<MAX_X, MAX_Y, MAX_T>,
    temp: f64,
    burnin: usize,
    iterations: usize,
) -> (MetropolisSimResult, MarkovChain)
where
    [(); MAX_X * MAX_Y * MAX_T]:,
{
    // Initialize a field to compare against
    let field: Field3d<i8, MAX_X, MAX_Y, MAX_T> = Field3d::random(&lattice);
    let mut field: Field3d<i32, MAX_X, MAX_Y, MAX_T> = Field3d::from_field(field);

    // Sweeps to achieve equilibrium
    for _ in 0..burnin {
        field.metropolis_sweep(temp);
    }

    // After having reached equilibrium, for each consecutive field configuration
    // that is generated by the markov chain, we calculate the observable and average it.
    let mut sim_obs_ary: Vec<f64> = Vec::with_capacity(iterations); // Simulation observable arrray
    for _sweeps in 0..iterations {
        field.metropolis_sweep(temp);
        sim_obs_ary.push(field.lattice_action(temp));
    }

    // Mean value of the lattice actions generated by the sim
    let observable: f64 = sim_obs_ary.iter().sum::<f64>() / sim_obs_ary.len() as f64;

    let data = MarkovChain(sim_obs_ary);

    let results: MetropolisSimResult = MetropolisSimResult {
        temp,
        burnin,
        iterations,
        observable,
    };

    println!("{:?}", results);

    (results, data)
}
