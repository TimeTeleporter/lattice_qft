use std::ops::Deref;

use serde::{Deserialize, Serialize};

use crate::{
    action::Action,
    cluster::Cluster,
    error::ObsChain,
    field::Field,
    lattice::{Lattice, Lattice3d},
    metropolis::Metropolis,
};

/// Datatype to save and read simulation output.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SimResult<'a, const D: usize>
where
    [(); D * 2_usize]:,
{
    name: &'a str,
    size: [usize; D],
    temp: f64,
    burnin: usize,
    iterations: usize,
    observable: f64,
    error: Option<f64>,
}

impl<'a, const D: usize> SimResult<'a, D>
where
    [(); D * 2_usize]:,
{
    pub fn new(
        name: &str,
        size: [usize; D],
        temp: f64,
        burnin: usize,
        iterations: usize,
        observable: f64,
        error: Option<f64>,
    ) -> Self {
        SimResult {
            name,
            size,
            temp,
            burnin,
            iterations,
            observable,
            error,
        }
    }

    pub fn set_error(&mut self, error_option: Option<f64>) {
        self.error = error_option;
    }
}

/// Simulation object
pub struct Simulation<'a, const D: usize, const SIZE: usize>
where
    [(); D * 2_usize]:,
{
    lattice: &'a Lattice<D, SIZE>,
    temp: f64,
    burnin: usize,
    iterations: usize,
    sweep_fn: fn(&mut Field<'a, i32, D, SIZE>, f64),
}

impl<'a, const D: usize, const SIZE: usize> Simulation<'a, D, SIZE>
where
    [(); D * 2_usize]:,
{
    pub fn new(
        lattice: &'a Lattice<D, SIZE>,
        temp: f64,
        burnin: usize,
        iterations: usize,
        sweep_fn: fn(&mut Field<'a, i32, D, SIZE>, f64),
    ) -> Self {
        Simulation {
            lattice,
            temp,
            burnin,
            iterations,
            sweep_fn,
        }
    }

    pub fn run(&mut self) -> (SimResult, ObsChain) {
        let field: Field<'a, i8, D, SIZE> = Field::random(self.lattice);
        let mut field: Field<'a, i32, D, SIZE> = Field::from_field(field);

        // Brunin: compute an amount of sweeps to achieve equilibrium
        for _step in 0..self.burnin {
            //println!("{temp} Burnin sweep {_step}");
            (self.sweep_fn)(&mut field, self.temp);
            field.normalize_random();
        }

        // After having reached equilibrium, for each consecutive field configuration
        // that is generated by the markov chain, we calculate the observable and average it.
        let mut observable_array: Vec<f64> = Vec::with_capacity(self.iterations); // Simulation observable arrray
        for _step in 0..self.iterations {
            //println!("{temp} Sweep {_step}");
            (self.sweep_fn)(&mut field, self.temp);
            observable_array.push(field.lattice_action(self.temp));
            field.normalize_random();
        }

        // Mean value of the lattice actions generated by the simulation
        let observable: f64 = observable_array.iter().sum::<f64>() / observable_array.len() as f64;

        // Save the field configurations in order to do further calculations
        let data: ObsChain = ObsChain::new(observable_array);

        // Construct the return data type
        let results: SimResult =
            SimResult::new(self.temp, self.burnin, self.iterations, observable, None);

        (results, data)
    }

    fn produce_simresult(self, observable)
}

/// On a given lattice with given "temperature" ```e^2/2```, we simulate a
/// integer valued field by initializing it randomly and then proceed to do
/// cluster algorithm sweeps in order to calculate the observable
/// ```$e^2/2 \sum_{<ij>} (h_i - h_j)^2$```.
pub fn cluster_simulation<const D: usize, const SIZE: usize>(
    lattice: &Lattice<D, SIZE>,
    temp: f64,
    burnin: usize,
    iterations: usize,
) -> (SimResult, ObsChain)
where
    [(); D * 2_usize]:,
{
    let (result, data) = simulation(lattice, temp, burnin, iterations, Cluster::cluster_sweep);
    println!("Cluster {:?}", result);
    (result, data)
}

/// On a given lattice with given "temperature" ```e^2/2```, we simulate a
/// integer valued field by initializing it randomly and then proceed to do
/// cluster algorithm sweeps in order to calculate the observable
/// ```$e^2/2 \sum_{<ij>} (h_i - h_j)^2$```.
pub fn cluster_simulation3d<const MAX_X: usize, const MAX_Y: usize, const MAX_T: usize>(
    lattice: &Lattice3d<MAX_X, MAX_Y, MAX_T>,
    temp: f64,
    burnin: usize,
    iterations: usize,
) -> (SimResult, ObsChain)
where
    [(); MAX_X * MAX_Y * MAX_T]:,
{
    let lattice = lattice.deref();
    cluster_simulation(lattice, temp, burnin, iterations)
}

pub fn metropolis_simulation<const D: usize, const SIZE: usize>(
    lattice: &Lattice<D, SIZE>,
    temp: f64,
    burnin: usize,
    iterations: usize,
) -> (SimResult, ObsChain)
where
    [(); D * 2_usize]:,
{
    let (results, data) = simulation(
        lattice,
        temp,
        burnin,
        iterations,
        Metropolis::metropolis_sweep,
    );
    println!("Metropolis {:?}", results);
    (results, data)
}

pub fn metropolis_simulation3d<const MAX_X: usize, const MAX_Y: usize, const MAX_T: usize>(
    lattice: &Lattice3d<MAX_X, MAX_Y, MAX_T>,
    temp: f64,
    burnin: usize,
    iterations: usize,
) -> (SimResult, ObsChain)
where
    [(); MAX_X * MAX_Y * MAX_T]:,
{
    let lattice = lattice.deref();
    metropolis_simulation(lattice, temp, burnin, iterations)
}
