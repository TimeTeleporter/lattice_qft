use serde::{Deserialize, Serialize};

use crate::{
    action::Action, cluster::Cluster, error::ObsChain, field::Field, lattice::Lattice,
    metropolis::Metropolis,
};

/// Datatype to save and read simulation output.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SimResult {
    name: String,
    pub temp: f64,
    burnin: usize,
    iterations: usize,
    observable: f64,
    error: Option<f64>,
}

impl SimResult {
    pub fn new(
        name: String,
        temp: f64,
        burnin: usize,
        iterations: usize,
        observable: f64,
        error: Option<f64>,
    ) -> Self {
        SimResult {
            name,
            temp,
            burnin,
            iterations,
            observable,
            error,
        }
    }

    pub fn set_error(&mut self, error_option: Option<f64>) {
        self.error = error_option;
    }
}

pub trait Simulation<
    const D: usize,
    const SIZE: usize,
    const BURNIN: usize,
    const ITERATIONS: usize,
> where
    [(); D * 2_usize]:,
{
    fn run(&mut self) -> (SimResult, ObsChain) {
        let mut field: Field<i32, D, SIZE> = self.build_field();

        // Brunin: compute an amount of sweeps to achieve equilibrium
        for _step in 0..BURNIN {
            //println!("{temp} Burnin sweep {_step}");
            Self::simulate(&self, &mut field);
            field.normalize_random();
        }

        // After having reached equilibrium, for each consecutive field configuration
        // that is generated by the markov chain, we calculate the observable and average it.
        let mut observable_array: Vec<f64> = Vec::with_capacity(ITERATIONS); // Simulation observable arrray
        for _step in 0..ITERATIONS {
            Self::simulate(&self, &mut field);
            observable_array.push(Self::get_observable(&self, &field));
            field.normalize_random();
        }

        // Mean value of the lattice actions generated by the simulation
        let observable: f64 = observable_array.iter().sum::<f64>() / observable_array.len() as f64;

        // Save the field configurations in order to do further calculations
        let data: ObsChain = ObsChain::new(observable_array);

        // Construct the return data type
        let results: SimResult = self.produce_simresult(observable);

        (results, data)
    }

    fn build_field(&self) -> Field<i32, D, SIZE>;
    fn simulate(&self, field: &mut Field<i32, D, SIZE>);
    fn get_observable(&self, field: &Field<i32, D, SIZE>) -> f64;
    fn produce_simresult(&self, observable: f64) -> SimResult;
}

pub struct ClusterSim<
    'a,
    const D: usize,
    const SIZE: usize,
    const BURNIN: usize,
    const ITERATIONS: usize,
> where
    [(); D * 2_usize]:,
{
    name: String,
    lattice: &'a Lattice<D, SIZE>,
    temp: f64,
}

impl<'a, const D: usize, const SIZE: usize, const BURNIN: usize, const ITERATIONS: usize>
    ClusterSim<'a, D, SIZE, BURNIN, ITERATIONS>
where
    [(); D * 2_usize]:,
{
    pub fn new(name: String, lattice: &'a Lattice<D, SIZE>, temp: f64) -> Self {
        ClusterSim {
            name,
            lattice,
            temp,
        }
    }
}

impl<'a, const D: usize, const SIZE: usize, const BURNIN: usize, const ITERATIONS: usize>
    Simulation<D, SIZE, BURNIN, ITERATIONS> for ClusterSim<'a, D, SIZE, BURNIN, ITERATIONS>
where
    [(); D * 2_usize]:,
{
    fn build_field(&self) -> Field<i32, D, SIZE> {
        let field: Field<i8, D, SIZE> = Field::random(self.lattice);
        let field: Field<i32, D, SIZE> = Field::from_field(field);
        field
    }

    fn simulate(&self, field: &mut Field<i32, D, SIZE>) {
        field.cluster_sweep(self.temp);
    }

    fn get_observable(&self, field: &Field<i32, D, SIZE>) -> f64 {
        field.lattice_action(self.temp)
    }

    fn produce_simresult(&self, observable: f64) -> SimResult {
        SimResult {
            name: self.name.clone(),
            temp: self.temp,
            burnin: BURNIN,
            iterations: ITERATIONS,
            observable,
            error: None,
        }
    }
}

pub struct MetrplsSim<
    'a,
    const D: usize,
    const SIZE: usize,
    const BURNIN: usize,
    const ITERATIONS: usize,
> where
    [(); D * 2_usize]:,
{
    name: String,
    lattice: &'a Lattice<D, SIZE>,
    temp: f64,
}

impl<'a, const D: usize, const SIZE: usize, const BURNIN: usize, const ITERATIONS: usize>
    MetrplsSim<'a, D, SIZE, BURNIN, ITERATIONS>
where
    [(); D * 2_usize]:,
{
    pub fn new(name: String, lattice: &'a Lattice<D, SIZE>, temp: f64) -> Self {
        MetrplsSim {
            name,
            lattice,
            temp,
        }
    }
}

impl<'a, const D: usize, const SIZE: usize, const BURNIN: usize, const ITERATIONS: usize>
    Simulation<D, SIZE, BURNIN, ITERATIONS> for MetrplsSim<'a, D, SIZE, BURNIN, ITERATIONS>
where
    [(); D * 2_usize]:,
{
    fn build_field(&self) -> Field<i32, D, SIZE> {
        let field: Field<i8, D, SIZE> = Field::random(self.lattice);
        let field: Field<i32, D, SIZE> = Field::from_field(field);
        field
    }

    fn simulate(&self, field: &mut Field<i32, D, SIZE>) {
        field.metropolis_sweep(self.temp);
    }

    fn get_observable(&self, field: &Field<i32, D, SIZE>) -> f64 {
        field.lattice_action(self.temp)
    }

    fn produce_simresult(&self, observable: f64) -> SimResult {
        SimResult {
            name: self.name.clone(),
            temp: self.temp,
            burnin: BURNIN,
            iterations: ITERATIONS,
            observable,
            error: None,
        }
    }
}

pub enum Simulations3d<
    'a,
    const MAX_X: usize,
    const MAX_Y: usize,
    const MAX_T: usize,
    const BURNIN: usize,
    const ITERATIONS: usize,
> where
    [(); MAX_X * MAX_Y * MAX_T]:,
{
    ClusterSim3d(ClusterSim<'a, 3, { MAX_X * MAX_Y * MAX_T }, BURNIN, ITERATIONS>),
    MetropolisSim3d(MetrplsSim<'a, 3, { MAX_X * MAX_Y * MAX_T }, BURNIN, ITERATIONS>),
}
