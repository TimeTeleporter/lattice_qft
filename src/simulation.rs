use std::ops::Deref;

use serde::{Deserialize, Serialize};

use crate::{
    action::Action,
    cluster::Cluster,
    error::ObsChain,
    field::Field,
    lattice::{Lattice, Lattice3d},
    metropolis::Metropolis,
};

/// Datatype to save and read simulation output.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SimResult {
    temp: f64,
    burnin: usize,
    iterations: usize,
    observable: f64,
    error: Option<f64>,
}

impl SimResult {
    pub fn new(
        temp: f64,
        burnin: usize,
        iterations: usize,
        observable: f64,
        error: Option<f64>,
    ) -> Self {
        SimResult {
            temp,
            burnin,
            iterations,
            observable,
            error,
        }
    }

    pub fn set_error(&mut self, error_option: Option<f64>) {
        self.error = error_option;
    }
}

pub fn simulation<'a, const D: usize, const SIZE: usize>(
    lattice: &'a Lattice<D, SIZE>,
    temp: f64,
    burnin: usize,
    iterations: usize,
    sweep_fn: fn(&mut Field<'a, i32, D, SIZE>, f64),
) -> (SimResult, ObsChain)
where
    [(); D * 2_usize]:,
{
    // Initialize a integer valued field with randomized initial values between
    // -128 and 127.
    let field: Field<i8, D, SIZE> = Field::random(&lattice);
    let mut field: Field<i32, D, SIZE> = Field::from_field(field);

    // Brunin: compute an amount of sweeps to achieve equilibrium
    for _step in 0..burnin {
        //println!("{temp} Burnin sweep {_step}");
        sweep_fn(&mut field, temp);
        field.normalize_random();
    }

    // After having reached equilibrium, for each consecutive field configuration
    // that is generated by the markov chain, we calculate the observable and average it.
    let mut observable_array: Vec<f64> = Vec::with_capacity(iterations); // Simulation observable arrray
    for _step in 0..iterations {
        //println!("{temp} Sweep {_step}");
        sweep_fn(&mut field, temp);
        observable_array.push(field.lattice_action(temp));
        field.normalize_random();
    }

    // Mean value of the lattice actions generated by the simulation
    let observable: f64 = observable_array.iter().sum::<f64>() / observable_array.len() as f64;

    // Save the field configurations in order to do further calculations
    let data: ObsChain = ObsChain::new(observable_array);

    // Construct the return data type
    let results: SimResult = SimResult::new(temp, burnin, iterations, observable, None);

    (results, data)
}

/// On a given lattice with given "temperature" ```e^2/2```, we simulate a
/// integer valued field by initializing it randomly and then proceed to do
/// cluster algorithm sweeps in order to calculate the observable
/// ```$e^2/2 \sum_{<ij>} (h_i - h_j)^2$```.
pub fn cluster_simulation<const D: usize, const SIZE: usize>(
    lattice: &Lattice<D, SIZE>,
    temp: f64,
    burnin: usize,
    iterations: usize,
) -> (SimResult, ObsChain)
where
    [(); D * 2_usize]:,
{
    let (result, data) = simulation(lattice, temp, burnin, iterations, Cluster::cluster_sweep);
    println!("Cluster {:?}", result);
    (result, data)
}

/// On a given lattice with given "temperature" ```e^2/2```, we simulate a
/// integer valued field by initializing it randomly and then proceed to do
/// cluster algorithm sweeps in order to calculate the observable
/// ```$e^2/2 \sum_{<ij>} (h_i - h_j)^2$```.
pub fn cluster_simulation3d<const MAX_X: usize, const MAX_Y: usize, const MAX_T: usize>(
    lattice: &Lattice3d<MAX_X, MAX_Y, MAX_T>,
    temp: f64,
    burnin: usize,
    iterations: usize,
) -> (SimResult, ObsChain)
where
    [(); MAX_X * MAX_Y * MAX_T]:,
{
    let lattice = lattice.deref();
    cluster_simulation(lattice, temp, burnin, iterations)
}

pub fn metropolis_simulation<const D: usize, const SIZE: usize>(
    lattice: &Lattice<D, SIZE>,
    temp: f64,
    burnin: usize,
    iterations: usize,
) -> (SimResult, ObsChain)
where
    [(); D * 2_usize]:,
{
    let (results, data) = simulation(
        lattice,
        temp,
        burnin,
        iterations,
        Metropolis::metropolis_sweep,
    );
    println!("Metropolis {:?}", results);
    (results, data)
}

pub fn metropolis_simulation3d<const MAX_X: usize, const MAX_Y: usize, const MAX_T: usize>(
    lattice: &Lattice3d<MAX_X, MAX_Y, MAX_T>,
    temp: f64,
    burnin: usize,
    iterations: usize,
) -> (SimResult, ObsChain)
where
    [(); MAX_X * MAX_Y * MAX_T]:,
{
    let lattice = lattice.deref();
    metropolis_simulation(lattice, temp, burnin, iterations)
}
