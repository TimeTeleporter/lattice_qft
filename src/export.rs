use std::{error::Error, fs::File};

use serde::{Deserialize, Serialize};

pub trait CsvData {
    fn read_write_csv(self, path: &str) -> Result<(), Box<dyn Error>>;
    fn overwrite_csv(self, path: &str) -> Result<(), Box<dyn Error>>;
}

impl<T> CsvData for T
where
    T: Serialize + for<'a> Deserialize<'a>,
{
    fn read_write_csv(self, path: &str) -> Result<(), Box<dyn Error>> {
        // Initialize data storage
        let mut storage: Vec<T> = Vec::new();

        read_from_csv(path, &mut storage)?;

        // Append the new entry
        storage.push(self);

        // Write to the file
        write_to_csv(path, storage)?;

        Ok(())
    }

    fn overwrite_csv(self, path: &str) -> Result<(), Box<dyn Error>> {
        // Initialize data storage
        let mut storage: Vec<T> = Vec::new();

        // Append the new entry
        storage.push(self);

        write_to_csv(path, storage)?;

        Ok(())
    }
}

fn write_to_csv<T>(path: &str, storage: Vec<T>) -> Result<(), Box<dyn Error>>
where
    T: Serialize + for<'a> Deserialize<'a>,
{
    let mut wtr = csv::Writer::from_path(path)?;
    for data in storage {
        wtr.serialize(data)?;
    }
    wtr.flush()?;
    Ok(())
}

fn read_from_csv<T>(path: &str, storage: &mut Vec<T>) -> Result<(), Box<dyn Error>>
where
    T: Serialize + for<'a> Deserialize<'a>,
{
    let file = File::open(path)?;
    let mut rdr = csv::Reader::from_reader(file);
    Ok(for result in rdr.deserialize() {
        let test_data: T = result?;
        storage.push(test_data);
    })
}

pub fn clean_csv(path: &str) -> Result<(), Box<dyn Error>> {
    let storage: Vec<()> = Vec::new();
    write_to_csv(path, storage)?;
    Ok(())
}

// ----------------------------------------------------------------------------

/// Datatype to save and read simulation output.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SimResult {
    temp: f64,
    burnin: usize,
    iterations: usize,
    observable: f64,
}

impl SimResult {
    pub fn new(temp: f64, burnin: usize, iterations: usize, observable: f64) -> Self {
        SimResult {
            temp,
            burnin,
            iterations,
            observable,
        }
    }
}

// ----------------------------------------------------------------------------

/// A wrapper for the Markov chain elements generated by the Metropolis simulation.
#[derive(Debug, Serialize, Deserialize)]
pub struct MarkovChain(Vec<f64>);

impl MarkovChain {
    pub fn new(vec: Vec<f64>) -> Self {
        MarkovChain(vec)
    }

    pub fn calculate_mean_value(&self) -> f64 {
        self.0.iter().sum::<f64>() / self.0.len() as f64
    }

    pub fn calulate_variance(&self) -> f64 {
        let mean = self.calculate_mean_value();

        self.0.iter().map(|&x| (x - mean) * (x - mean)).sum::<f64>() / (self.0.len() as f64)
    }

    pub fn binning(&mut self) -> Self {
        let new_len: usize = self.0.len() / 2;
        let mut new_set: Vec<f64> = Vec::with_capacity(new_len);

        for index in 0..new_len {
            let first: f64 = self.0[index * 2];

            let mean: f64 = if let Some(second) = self.0.get((index * 2) + 1) {
                (first + second) / 2.0
            } else {
                first
            };

            new_set.push(mean);
        }

        MarkovChain(new_set)
    }
}

// ----------------------------------------------------------------------------

/// Datatype to save and read binned simulation output.
#[derive(Debug, Serialize, Deserialize)]
pub struct BinData {
    temp: f64,
    binning_step: u32,
    variance: f64, // The square of the standard deviation
    std: f64,
    error: f64,
}

impl MarkovChain {
    pub fn calculate_bin_var(mut self, temp: f64) -> Vec<BinData> {
        let mut results: Vec<BinData> = Vec::new();
        let original_length: usize = self.0.len();

        let mut binning_step: u32 = 0;
        while 2_usize.pow(binning_step) < original_length {
            // Printing
            results.push(self.get_bin_data(temp, binning_step));

            // Binning
            self = self.binning();
            binning_step += 1;
        }

        results
    }

    pub fn get_bin_data(&self, temp: f64, binning_step: u32) -> BinData {
        // Calculating the relevant values
        let variance: f64 = self.calulate_variance();
        let std: f64 = variance.sqrt();
        let error: f64 = std / ((self.0.len() - 1) as f64).sqrt();

        BinData {
            temp,
            binning_step,
            variance,
            std,
            error,
        }
    }
}
