use std::{error::Error, fs::File};

use rulinalg::{
    matrix::{BaseMatrix, Matrix},
    vector::Vector,
};
use serde::{Deserialize, Serialize};

pub trait CsvData {
    fn read_write_csv(self, path: &str) -> Result<(), Box<dyn Error>>;
    fn overwrite_csv(self, path: &str) -> Result<(), Box<dyn Error>>;
    fn fetch_csv_data(path: &str) -> Result<Vec<Self>, Box<dyn Error>>
    where
        Self: Sized;
}

impl<T> CsvData for T
where
    T: Serialize + for<'a> Deserialize<'a>,
{
    fn read_write_csv(self, path: &str) -> Result<(), Box<dyn Error>> {
        // Initialize data storage
        let mut storage: Vec<T> = Vec::new();

        read_from_csv(path, &mut storage)?;

        // Append the new entry
        storage.push(self);

        // Write to the file
        write_to_csv(path, storage)?;

        Ok(())
    }

    fn overwrite_csv(self, path: &str) -> Result<(), Box<dyn Error>> {
        // Initialize data storage
        let mut storage: Vec<T> = Vec::new();

        // Append the new entry
        storage.push(self);

        write_to_csv(path, storage)?;

        Ok(())
    }

    fn fetch_csv_data(path: &str) -> Result<Vec<T>, Box<dyn Error>> {
        let mut storage: Vec<T> = Vec::new();

        read_from_csv(path, &mut storage)?;

        Ok(storage)
    }
}

fn write_to_csv<T>(path: &str, storage: Vec<T>) -> Result<(), Box<dyn Error>>
where
    T: Serialize + for<'a> Deserialize<'a>,
{
    let mut wtr = csv::Writer::from_path(path)?;
    for data in storage {
        wtr.serialize(data)?;
    }
    wtr.flush()?;
    Ok(())
}

fn read_from_csv<T>(path: &str, storage: &mut Vec<T>) -> Result<(), Box<dyn Error>>
where
    T: Serialize + for<'a> Deserialize<'a>,
{
    let file = File::open(path)?;
    let mut rdr = csv::Reader::from_reader(file);
    Ok(for result in rdr.deserialize() {
        let test_data: T = result?;
        storage.push(test_data);
    })
}

pub fn clean_csv(path: &str) -> Result<(), Box<dyn Error>> {
    let storage: Vec<()> = Vec::new();
    write_to_csv(path, storage)?;
    Ok(())
}

// ----------------------------------------------------------------------------

/// Datatype to save and read simulation output.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SimResult {
    temp: f64,
    burnin: usize,
    iterations: usize,
    observable: f64,
    error: Option<f64>,
}

impl SimResult {
    pub fn new(
        temp: f64,
        burnin: usize,
        iterations: usize,
        observable: f64,
        error: Option<f64>,
    ) -> Self {
        SimResult {
            temp,
            burnin,
            iterations,
            observable,
            error,
        }
    }

    pub fn set_error(&mut self, error_option: Option<f64>) {
        self.error = error_option;
    }
}

/// Datatype to save and read binned simulation output.
#[derive(Debug, Serialize, Deserialize)]
pub struct BinData {
    temp: f64,
    binning_step: u32,
    variance: f64, // The square of the standard deviation
    std: f64,
    error: f64,
}

/// A wrapper for the Markov chain elements generated by the Metropolis simulation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ObsChain(Vec<f64>);

impl ObsChain {
    pub fn new(vec: Vec<f64>) -> Self {
        ObsChain(vec)
    }

    pub fn calculate_mean_value(&self) -> f64 {
        self.0.iter().sum::<f64>() / self.0.len() as f64
    }

    pub fn calulate_variance(&self) -> f64 {
        let mean = self.calculate_mean_value();

        self.0.iter().map(|&x| (x - mean) * (x - mean)).sum::<f64>() / (self.0.len() as f64)
    }

    // By iteratively averaging two adjacent data points we intend to find the true error
    pub fn binning(&mut self) -> Self {
        let new_len: usize = self.0.len() / 2;
        let mut new_set: Vec<f64> = Vec::with_capacity(new_len);

        for index in 0..new_len {
            let first: f64 = self.0[index * 2];

            let mean: f64 = if let Some(second) = self.0.get((index * 2) + 1) {
                (first + second) / 2.0
            } else {
                continue;
            };

            new_set.push(mean);
        }

        ObsChain(new_set)
    }

    pub fn calculate_bin_var(mut self, temp: f64) -> Vec<BinData> {
        let mut results: Vec<BinData> = Vec::new();
        let original_length: usize = self.0.len();

        let mut binning_step: u32 = 0;
        while 2_usize.pow(binning_step) < original_length {
            // Printing
            results.push(self.get_bindata(temp, binning_step));

            // Binning
            self = self.binning();
            binning_step += 1;
        }

        results
    }

    pub fn get_bindata(&self, temp: f64, binning_step: u32) -> BinData {
        // Calculating the relevant values
        let variance: f64 = self.calulate_variance();
        let std: f64 = variance.sqrt();
        let error: f64 = std / ((self.0.len() - 1) as f64).sqrt();

        BinData {
            temp,
            binning_step,
            variance,
            std,
            error,
        }
    }
}

const VERBOSE_BINNED_ERROR: bool = false;

pub fn calculate_binned_error(bindata_ary: &Vec<BinData>) -> Result<f64, Box<dyn Error>> {
    let mut x_values: Vec<u32> = bindata_ary.iter().map(|data| data.binning_step).collect();
    let mut y_values: Vec<f64> = bindata_ary.into_iter().map(|data| data.error).collect();
    while y_values.last().is_some_and(|y| y.is_nan()) {
        y_values.pop();
        x_values.pop();
    }
    assert_eq!(x_values.len(), y_values.len());

    // Setting initial parameters
    let (mut a, mut b, mut c): (f64, f64, f64) = (y_values[0] * 2.0, y_values[0], 0.7);
    if VERBOSE_BINNED_ERROR {
        println!("a: {a}, b: {b}, c: {c}");
    }

    const FN_PARAM: usize = 3;

    for _ in 0..2 {
        let mat: Matrix<f64> = Matrix::from_fn(x_values.len(), FN_PARAM, |col_index, row_index| {
            if VERBOSE_BINNED_ERROR {
                println!("Matri: row: {row_index}, col: {col_index}");
            }
            let x: f64 = x_values[row_index] as f64;
            match col_index {
                0 => 1.0,
                1 => (-1.0 * x * c).exp(),
                2 => -1.0 * (-1.0 * x * c).exp() * b * x,
                _ => {
                    panic!("Columns out of bounds");
                }
            }
        });
        if VERBOSE_BINNED_ERROR {
            println!("{}", mat);
        }

        let sqr = mat.transpose() * mat.clone();
        if VERBOSE_BINNED_ERROR {
            println!("sqr: {:?}", sqr);
        }
        let inv = sqr.inverse()?;
        if VERBOSE_BINNED_ERROR {
            println!("inv: {:?}", inv);
        }
        let vectr = Vector::new(y_values.clone());
        if VERBOSE_BINNED_ERROR {
            println!("vectr: {}", vectr);
        }
        let prod = inv * mat.transpose();
        if VERBOSE_BINNED_ERROR {
            println!("prod: {}", prod);
        }
        let res: Vector<f64> = prod * vectr;
        println!("res: {:?}", res);
        let res = res.data();
        assert_eq!(res.len(), 3);
        (a, b, c) = (res[0], res[1], res[2]);
    }

    println!("Error calculated {a}");

    Ok(a)
}
