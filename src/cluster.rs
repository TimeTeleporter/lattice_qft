use std::ops::{Add, Deref, Div, Mul, Sub};

use rand::{rngs::ThreadRng, Rng};

use crate::{
    action::Action,
    export::{ObsChain, SimResult},
    field::Field,
    lattice::{Lattice, Lattice3d},
};

use self::bonds::BondsField;

pub trait Cluster: Action {
    fn cluster_sweep(&mut self, temp: f64);
}

impl<'a, T, const D: usize, const SIZE: usize> Cluster for Field<'a, T, D, SIZE>
where
    f64: From<T>,
    T: Add<Output = T>
        + Sub<Output = T>
        + Mul<Output = T>
        + Div<Output = T>
        + Default
        + From<i8>
        + Into<i64>
        + Into<f64>
        + PartialOrd
        + Copy,
    [(); D * 2_usize]:,
{
    fn cluster_sweep(&mut self, temp: f64) {
        let mut rng = ThreadRng::default();
        //println!("{temp} Sweep");

        // Set the mirror plane randomly on a height value
        let plane: T = self.values[rng.gen_range(0..SIZE)];
        let modifier: T = match rng.gen::<bool>() {
            true => 0_i8.into(),
            false => match rng.gen::<bool>() {
                true => (-1_i8).into(),
                false => 1_i8.into(),
            },
        };
        //println!("Plane and modifier set");

        // Calculate the reflected field
        let reflected: Field<T, D, SIZE> = self.clone().mirror_values(plane, modifier);
        //println!("Reflected field calculated");

        // Activate links if they are on the same side of the plane:
        let mut bonds: BondsField<D, SIZE> = BondsField::new(self.lattice);
        //println!("Bonds initialized");

        // Going through the lattice sites...
        for index in 0..SIZE {
            // ...for each neighbour in positive coordinate direction...
            for (direction, &neighbour) in
                self.lattice.pos_neighbours_array(index).iter().enumerate()
            {
                // ...calculate both the normal and the reflected action of the
                // link between them.
                let action: T = <Self as Action>::calculate_link_action(
                    self.values[index],
                    self.values[neighbour],
                );
                let reflected_action: T = <Self as Action>::calculate_link_action(
                    reflected.values[index],
                    self.values[neighbour],
                );

                // Dont activate a bond if both are on the same side.
                if action >= reflected_action {
                    continue;
                }

                // Activate the link with probability 1 - exp(S - S').
                let draw: f64 = rng.gen_range(0.0..=1.0);
                let prob: f64 = 1.0 - (Into::<f64>::into(action - reflected_action) * temp).exp();
                if draw <= prob {
                    bonds.activate(index, direction)
                }
            }
        }
        //println!("Bonds activated");

        // Build the clusters
        let clusters: Vec<Vec<usize>> = bonds.collect_clusters();
        //println!("Clusters built");

        // For each cluster decide to flip it
        for cluster in clusters {
            let coin: bool = rng.gen();
            if coin {
                for index in cluster {
                    self.values[index] = reflected.values[index];
                }
            }
        }
    }
}

// ----------------------------------------------------------------------------

pub fn cluster_simulation<const D: usize, const SIZE: usize>(
    lattice: &Lattice<D, SIZE>,
    temp: f64,
    burnin: usize,
    iterations: usize,
) -> (SimResult, ObsChain)
where
    [(); D * 2_usize]:,
{
    // Initialize a field to compare against
    let field: Field<i8, D, SIZE> = Field::random(&lattice);
    let mut field: Field<i32, D, SIZE> = Field::from_field(field);

    // Sweeps to achieve equilibrium
    for _ in 0..burnin {
        field.cluster_sweep(temp);
        field.normalize_random();
    }

    // After having reached equilibrium, for each consecutive field configuration
    // that is generated by the markov chain, we calculate the observable and average it.
    let mut sim_obs_ary: Vec<f64> = Vec::with_capacity(iterations); // Simulation observable arrray
    for _sweeps in 0..iterations {
        field.cluster_sweep(temp);
        sim_obs_ary.push(field.lattice_action(temp));
        field.normalize_random();
    }

    // Mean value of the lattice actions generated by the sim
    let observable: f64 = sim_obs_ary.iter().sum::<f64>() / sim_obs_ary.len() as f64;

    let data: ObsChain = ObsChain::new(sim_obs_ary);

    let results: SimResult = SimResult::new(temp, burnin, iterations, observable, None);

    println!("Cluster{:?}", results);

    (results, data)
}

pub fn cluster_simulation3d<const MAX_X: usize, const MAX_Y: usize, const MAX_T: usize>(
    lattice: &Lattice3d<MAX_X, MAX_Y, MAX_T>,
    temp: f64,
    burnin: usize,
    iterations: usize,
) -> (SimResult, ObsChain)
where
    [(); MAX_X * MAX_Y * MAX_T]:,
{
    let lattice = lattice.deref();
    cluster_simulation(lattice, temp, burnin, iterations)
}

// ----------------------------------------------------------------------------

pub(self) mod bonds {
    use std::ops::Deref;

    use crate::{field::Field, lattice::Lattice};

    /// Models the activation of outgoing bonds from a lattice site
    pub struct BondsField<'a, const D: usize, const SIZE: usize>(
        Field<'a, [bool; D * 2_usize], D, SIZE>,
    )
    where
        [(); D * 2_usize]:;

    impl<'a, const D: usize, const SIZE: usize> BondsField<'a, D, SIZE>
    where
        [(); D * 2_usize]:,
    {
        /// Constructor for a new BondsField on the lattice initialized to be false everywhere.
        pub fn new(lattice: &'a Lattice<D, SIZE>) -> Self {
            let values: Vec<()> = vec![(); lattice.size.iter().product()];
            let values: Vec<[bool; D * 2_usize]> =
                values.into_iter().map(|_| [false; D * 2_usize]).collect();

            BondsField(Field::<'a, [bool; D * 2_usize], D, SIZE> { values, lattice })
        }

        /// Activate a link of the BondsField
        pub fn activate(&mut self, index: usize, direction: usize) {
            let neighbour = self.0.lattice.get_neighbours_array(index)[direction];
            self.0.values[index][direction] = true;
            self.0.values[neighbour][(direction + D) % (D * 2_usize)] = true;
        }

        /// Return collection of all clusters
        pub fn collect_clusters(self) -> Vec<Vec<usize>> {
            let mut unvisited: Vec<bool> = vec![true; SIZE];
            let mut clusters: Vec<Vec<usize>> = Vec::new();
            for index in 0..SIZE {
                if unvisited[index] {
                    clusters.push(self.build_cluster(index, &mut unvisited));
                }
            }

            clusters
        }

        /// Build a cluster from activated bonds
        fn build_cluster(&self, index: usize, unvisited: &mut Vec<bool>) -> Vec<usize> {
            let mut cluster: Vec<usize> = Vec::new();
            let mut checklist: Vec<usize> = Vec::new();
            checklist.push(index);
            unvisited[index] = false;

            while let Some(index) = checklist.pop() {
                cluster.push(index);

                for (direction, neighbour) in self
                    .0
                    .lattice
                    .get_neighbours_array(index)
                    .into_iter()
                    .enumerate()
                {
                    if self.0.values[neighbour][direction] && unvisited[neighbour] {
                        checklist.push(neighbour);
                        unvisited[neighbour] = false;
                    }
                }
            }

            cluster
        }
    }

    impl<'a, const D: usize, const SIZE: usize> Deref for BondsField<'a, D, SIZE>
    where
        [(); D * 2_usize]:,
    {
        type Target = Field<'a, [bool; D * 2_usize], D, SIZE>;

        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[test]
    fn test_bonds_field() {
        const D: usize = 3;
        const SIZE_ARY: [usize; D] = [4, 5, 3];
        const SIZE: usize = SIZE_ARY[0] * SIZE_ARY[1] * SIZE_ARY[2];

        let lattice: Lattice<D, SIZE> = Lattice::new(SIZE_ARY);
        let mut bonds_field: BondsField<D, SIZE> = BondsField::new(&lattice);

        // Setting the bond at [0, 2, 1] (index = 28) in the third direction
        // (direction = 2).
        assert_eq!(bonds_field.values[28][2], false);
        assert_eq!(bonds_field.values[48][5], false);
        bonds_field.activate(28, 2);
        //bonds_field.print_values_formated(SIZE_ARY);
        assert_eq!(bonds_field.values[28][2], true);
        assert_eq!(bonds_field.values[48][5], true);

        // Setting the bond at [2, 1, 0] (index = 6) in the negatice first direction
        // (direction = 3).
        assert_eq!(bonds_field.values[6][3], false);
        assert_eq!(bonds_field.values[5][0], false);
        bonds_field.activate(6, 3);
        assert_eq!(bonds_field.values[6][3], true);
        assert_eq!(bonds_field.values[5][0], true);
    }

    #[test]
    fn test_all_bonds_deactivated() {
        const D: usize = 3;
        const SIZE_ARY: [usize; D] = [4, 5, 3];
        const SIZE: usize = SIZE_ARY[0] * SIZE_ARY[1] * SIZE_ARY[2];

        let lattice: Lattice<D, SIZE> = Lattice::new(SIZE_ARY);
        let bonds_field: BondsField<D, SIZE> = BondsField::new(&lattice);

        let clusters: Vec<Vec<usize>> = bonds_field.collect_clusters();

        let mut test: Vec<Vec<usize>> = Vec::new();
        for index in 0..SIZE {
            let mut vect: Vec<usize> = Vec::new();
            vect.push(index);
            test.push(vect);
        }

        assert_eq!(test, clusters);
    }

    #[test]
    fn test_all_bonds_active() {
        const D: usize = 3;
        const SIZE_ARY: [usize; D] = [4, 5, 3];
        const SIZE: usize = SIZE_ARY[0] * SIZE_ARY[1] * SIZE_ARY[2];

        let lattice: Lattice<D, SIZE> = Lattice::new(SIZE_ARY);
        let mut bonds_field: BondsField<D, SIZE> = BondsField::new(&lattice);

        for bonds in bonds_field.0.values.iter_mut() {
            for bond in bonds.iter_mut() {
                *bond = true;
            }
        }

        let clusters: Vec<Vec<usize>> = bonds_field.collect_clusters();

        let mut test: Vec<Vec<usize>> = Vec::new();
        let mut cluster: Vec<usize> = Vec::with_capacity(SIZE);
        for index in 0..SIZE {
            cluster.push(index);
        }
        test.push(cluster);

        assert_eq!(test.len(), clusters.len());
    }
}
